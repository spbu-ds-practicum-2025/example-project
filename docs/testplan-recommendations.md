# Рекомендации по составлению плана E2E тестирования

## Введение

Данный документ содержит рекомендации по составлению плана сквозного (end-to-end) тестирования для распределенных систем. Рекомендации основаны на опыте подготовки демонстрации проекта «Электронный кошелек».

---

## 1. Общие принципы

### 1.1. Фокус на MVP

**Проблема**: Попытка протестировать все возможные сценарии приводит к перегруженному плану, который невозможно выполнить за ограниченное время демо.

**Решение**:
Тестируйте только функциональность, входящую в MVP (Minimum Viable Product).

**Замечание:** Если вы успели сделать что-то из расширенного проекта, тоже не забудьте продумать для этих доработок тестовые сценарии.
Если у вас останется время на демо, можете продемонстрировать эти доработки.

**Пример**:
```
❌ Плохо: "Тест пополнения счета через банковскую карту" (если не входит в MVP)
✅ Хорошо: "Тест перевода между счетами" (основная функция MVP)
```

### 1.2. Тестирование бизнес-логики, а не валидации

**Проблема**: Слишком много тестов на валидацию входных данных (формат полей, отрицательные числа, длина строк и т.д.) отвлекают от демонстрации основной функциональности.

**Решение**:
- Оставьте только тесты на ошибки бизнес-логики:
  - Недостаточно средств на счете
  - Несуществующий ресурс (пользователь, счет и т.д.)
  - Бизнес-ограничения (нельзя перевести больше лимита и т.д.)
- Уберите тесты на валидацию формата данных из списка e2e тестов:
  - Отрицательные числа
  - Некорректный формат UUID
  - Слишком длинные строки
  - Отсутствующие обязательные поля

**Пример**:
```
❌ Плохо: "Тест с отрицательной суммой перевода" (валидация)
❌ Плохо: "Тест с невалидным UUID счета" (валидация)
✅ Хорошо: "Тест перевода с недостаточным балансом" (бизнес-логика)
✅ Хорошо: "Тест перевода на несуществующий счет" (бизнес-логика)
```
**Комментарий:** Безусловно, тесты на валидацию входных данных нужны. 
Однако такие тесты сводятся к проверкам API конкретного компонента и достаточно легко автоматизируются.
Поэтому намного логичнее их автоматизировать и добавить в набор тестов компонента, API которого требует валидации входных данных.  

### 1.3. Однозначность результатов

**Проблема**: Тесты с неопределенными результатами ("может быть вариант А или вариант Б") создают путаницу и невозможность объективной проверки.

**Решение**:
- Каждый тест должен иметь один четкий ожидаемый результат
- Если поведение системы не определено, сначала примите решение о том, как она должна работать
- Используйте конкретные числа вместо расплывчатых формулировок

**Пример**:
```
❌ Плохо: "Часть операций выполнится успешно, часть завершится ошибкой"
✅ Хорошо: "3 операции выполнятся успешно (HTTP 200), 2 завершатся ошибкой (HTTP 400), итоговый баланс = 100.00 RUB"

❌ Плохо: "Операция может быть записана в историю или может не быть записана"
✅ Хорошо: "Операция НЕ записывается в историю при ошибке валидации"

❌ Плохо: "Обновление происходит в течение нескольких секунд"
✅ Хорошо: "Обновление происходит немедленно (в течение 1 секунды)"
```

**Комментарий:** Из этого правила могут быть исключения, если вы тестируете некоторый вероятностный алгоритм.
Например, у вас есть два сервиса (A и B) и балансировщик, который с вероятностью X отправляет запрос к сервису A 
и с вероятностью 1 - X отправляет запрос к сервису B, и вы как раз тестируете работу балансировщика.
В таком случае по начальному состоянию и входным данным теста вы не можете однозначно отпределить ожидаемый результ - вам 
известно лишь, что результат будет элементом множества {A, B}. 
Соответственно, в таком случае имеет смысл сделать два теста:

1. "Быстрый" тест, проверяющий, что результат работы алгоритма действительно принадлежит множеству {A, B}.
Это легко можно продемонстрировать руками. 
2. "Медленный" тест, который контролирует, что вероятность выбора каждого из элементов множества совпадает с ожидаемой.
Такой тест должен сделать достаточно большое количество запросов, поэтому его однозначно нужно автоматизировать и не нужно показывать на демо.

### 1.4. Оптимальный объем для демо

**Проблема**: Слишком много тестов невозможно показать за отведенное время, слишком мало — не покрывает ключевую функциональность.

**Решение**:
Для **20-минутного демо** оптимально:
- **10-15 тестов** общее количество
- **6-8 тестов** для демонстрации в приоритетной последовательности
- Остальные тесты — как резерв или для вопросов

**Распределение по категориям**:
- Основная функциональность (позитивные сценарии): 30-40%
- Обработка ошибок (негативные сценарии): 20-30%
- Идемпотентность и корректность: 20-25%
- Консистентность данных: 10-15%
- Комплексные сценарии: 10-15%

---

## 2. Структура плана тестирования

### 2.1. Обязательные разделы

```markdown
# План E2E тестирования [Название проекта]

## Введение
- Краткое описание системы
- Охват MVP (что тестируется)
- Предусловия для всех тестов
- Способ выполнения тестов (API/UI)

## [Раздел 1]: Основная функциональность
### Тест X.1: Успешный сценарий
### Тест X.2: Ошибка бизнес-логики №1
### Тест X.3: Ошибка бизнес-логики №2

## [Раздел 2]: Идемпотентность (если применимо)
### Тест Y.1: Повторная операция
### Тест Y.2: Разные ключи

## [Раздел 3]: Консистентность данных
### Тест Z.1: Проверка согласованности
```

### 2.2. Структура отдельного теста

Каждый тест должен содержать:

```markdown
### Тест X.Y: Краткое название (3-7 слов)

**Цель**: Одно предложение, что проверяем

**Предусловия**:
- Конкретное состояние системы
- Существующие данные с конкретными значениями
- Доступные ресурсы

**Шаги**:
1. Конкретное действие 1
2. Конкретное действие 2
...

**Ожидаемый результат**:
- Однозначный результат 1
- Однозначный результат 2
- Конкретные значения данных после теста
```

---

## 3. Специфика тестирования через REST API

### 3.1. Формат описания запросов

**Рекомендуемый формат**:

**Шаги**:
1. Отправить HTTP-запрос:
   ```
   POST http://localhost:8080/api/resource
   Headers:
     Content-Type: application/json
     X-Custom-Header: value
   Body:
   {
     "field": "value",
     "amount": "100.00"
   }
   ```


### 3.2. Формат описания ответов

**Рекомендуемый формат**:

**Ожидаемый результат**:
- HTTP статус: 200 OK
- Тело ответа содержит:
  ```json
  {
    "id": "<uuid>",
    "status": "SUCCESS",
    "data": {...}
  }
  ```
- Состояние данных в системе изменилось на [конкретное значение]

### 3.3. Проверка побочных эффектов

Всегда указывайте, как проверить побочные эффекты операции:

```markdown
**Ожидаемый результат**:
- HTTP статус: 200 OK
- Баланс счета А уменьшился до 900.00 RUB (проверить через GET /accounts/{id})
- Баланс счета Б увеличился до 1100.00 RUB (проверить через GET /accounts/{id})
- Операция появилась в истории (проверить через GET /accounts/{id}/operations)
```

---

## 4. Специфика тестирования через UI

### 4.1. Формат описания действий

**Рекомендуемый формат**:
```markdown
**Шаги**:
1. Открыть страницу "Переводы"
2. В поле "Получатель" ввести ID счета: {account-B}
3. В поле "Сумма" ввести: 100.00
4. Нажать кнопку "Отправить перевод"
5. Дождаться появления уведомления об успехе
```

### 4.2. Описание визуальных результатов

```markdown
**Ожидаемый результат**:
- Появляется зеленое уведомление: "Перевод выполнен успешно"
- В таблице "Мой баланс" отображается: 900.00 RUB
- В таблице "История операций" появляется новая строка:
  - Тип: Перевод
  - Сумма: -100.00 RUB
  - Получатель: {account-B}
  - Статус: Успешно
```

### 4.3. Комбинированное тестирование (UI + API)

Если у вас есть и UI, и API, можно комбинировать:

```markdown
**Шаги**:
1. Через UI: выполнить перевод 100.00 RUB на счет Б
2. Дождаться уведомления об успехе
3. Через API: проверить баланс счета А (GET /accounts/{account-A})
4. Через API: проверить баланс счета Б (GET /accounts/{account-B})

**Ожидаемый результат**:
- UI показывает: "Перевод выполнен успешно"
- API возвращает баланс счета А: 900.00 RUB
- API возвращает баланс счета Б: 1100.00 RUB
```

---

## 5. Категории тестов

### 5.1. Позитивные сценарии (Happy Path)

**Когда использовать**: Демонстрация основной функциональности

**Примеры**:
- Успешное создание ресурса
- Успешное выполнение операции
- Успешное получение данных

**Что проверяем**:
- Корректность выполнения операции
- Корректность изменения состояния
- Корректность ответа системы

### 5.2. Негативные сценарии (бизнес-логика)

**Когда использовать**: Демонстрация обработки ошибок

**Примеры**:
- Недостаточно ресурсов (денег, прав доступа и т.д.)
- Несуществующий объект
- Нарушение бизнес-правил (превышение лимита и т.д.)

**Что проверяем**:
- Корректность кода ошибки
- Понятность сообщения об ошибке
- Сохранение консистентности (откат изменений)

### 5.3. Тесты на идемпотентность

**Когда использовать**: Если система должна поддерживать идемпотентность операций

**Примеры**:
- Повторная отправка успешного запроса
- Повторная отправка неуспешного запроса
- Разные операции с разными ключами

**Что проверяем**:
- Повторная операция не дублирует эффект
- Возвращается тот же результат
- Используется правильный механизм идемпотентности

### 5.4. Тесты на конкурентность

**Когда использовать**: Демонстрация корректной работы при параллельных запросах

**Примеры**:
- Несколько параллельных операций над одним ресурсом
- Конкурентные изменения общего состояния

**Что проверяем**:
- Отсутствие race conditions
- Отсутствие lost updates
- Корректность блокировок
- Консистентность итогового состояния

**Комментарий:** Такие тесты, однозначно, полезны. Однако они отнимут немало времени и их не то чтобы было удобно демонстрировать вручную. Поэтому можете оставить их на самый конец.

### 5.5. Тесты на консистентность

**Когда использовать**: Демонстрация согласованности данных в распределенной системе

**Примеры**:
- Согласованность данных в разных сервисах
- Согласованность истории и текущего состояния
- Сохранение инвариантов (сумма балансов, количество товаров и т.д.)

**Что проверяем**:
- Данные согласованы между компонентами
- Инварианты сохраняются
- Нет "потерянных" операций

### 5.6. Комплексные сценарии

**Когда использовать**: Демонстрация реалистичного использования системы

**Примеры**:
- Полный жизненный цикл бизнес-процесса
- Последовательность связанных операций
- Взаимодействие нескольких пользователей/компонентов

**Что проверяем**:
- Интеграция всех компонентов
- Работоспособность сквозного процесса
- Корректность на всех этапах

---

## 6. Рекомендации по приоритизации

### 6.1. Обязательные тесты (Must Have)

Эти тесты **ОБЯЗАТЕЛЬНО** должны быть в плане и показаны на демо:

1. **Успешный сценарий основной функции** — показывает, что система работает
2. **Основная ошибка бизнес-логики** — показывает обработку ошибок
3. **Комплексный сценарий** — показывает интеграцию компонентов
4. **Консистентность данных** — показывает корректность распределенной системы

### 6.2. Желательные тесты (Should Have)

Эти тесты **ЖЕЛАТЕЛЬНО** включить для полноты картины:

5. **Идемпотентность** — если реализована
6. **Дополнительная ошибка бизнес-логики** — для демонстрации покрытия
7. **Последовательность операций** — для демонстрации работоспособности
8. **Конкурентность** — если есть параллельные запросы (сложно демонстрировать вручную)

### 6.3. Опциональные тесты (Nice to Have)

Эти тесты можно включить, если осталось время:

9. Различные варианты успешных сценариев
10. Редкие граничные случаи
11. Проверка дополнительной функциональности

---

## 7. Последовательность демонстрации

### 7.1. Рекомендуемый порядок

```
1. Успешный позитивный сценарий (Happy Path)
   ↓ показывает, что система работает 
  
2. Основные ошибки бизнес-логики
   ↓ показывает обработку ошибок

3. Идемпотентность (если реализована)
   ↓ показывает надежность
   
4. Комплексный сценарий 
   ↓ показывает полный цикл
     
5. Консистентность данных
   ↓ показывает корректность распределенной системы
   
6. Прочие тесты: конкурентность (если осталось время)
```

### 7.2. Принципы построения последовательности

- **От простого к сложному**: начинайте с простых операций, переходите к сложным
- **От позитива к негативу**: сначала покажите, что работает, потом — как обрабатываются ошибки
- **Логическая связность**: каждый следующий тест может использовать данные предыдущего
- **Время на запас**: последние 2-3 теста — резерв на случай вопросов
---

## 8. Типичные ошибки и как их избежать

### ❌ Ошибка 1: Слишком много тестов

**Проблема**: План содержит 30-40 тестов, невозможно показать за демо

**Решение**: Ограничьте план 10-15 тестами, сфокусируйтесь на ключевой функциональности

### ❌ Ошибка 2: Тесты на валидацию вместо бизнес-логики

**Проблема**: Половина тестов проверяет формат полей и корректность ввода

**Решение**: Уберите все тесты на валидацию входных данных, оставьте бизнес-ошибки

### ❌ Ошибка 3: Неопределенные результаты

**Проблема**: "Может вернуть А или Б", "Операция может быть или не быть"

**Решение**: Примите четкое решение о поведении системы, укажите один конкретный результат

### ❌ Ошибка 4: Тестирование нереализованной функциональности

**Проблема**: План включает тесты для функций, которые "планируются в будущем"

**Решение**: Тестируйте только то, что реально реализовано в MVP

### ❌ Ошибка 5: Отсутствие конкретных значений

**Проблема**: "Баланс изменится", "Операция будет в истории"

**Решение**: Указывайте конкретные значения: "Баланс станет 900.00 RUB", "В истории появится операция с ID X"

### ❌ Ошибка 6: Смешение технологий тестирования

**Проблема**: В шагах упоминаются конкретные инструменты (Postman, curl, Selenium)

**Решение**: Описывайте действия абстрактно ("Отправить HTTP-запрос", "Нажать кнопку"), без привязки к инструментам

### ❌ Ошибка 7: Отсутствие проверки побочных эффектов

**Проблема**: Проверяется только HTTP-ответ, но не изменение данных в системе

**Решение**: Всегда проверяйте побочные эффекты (изменение балансов, появление записей в истории и т.д.)

### ❌ Ошибка 8: Непоследовательные предусловия или зависимости между тестами

**Проблема**: В тесте 5 используются данные, которые должны были быть созданы в тесте 3, но тест 3 выполнился с ошибкой

**Решение**: Каждый тест должен быть независимым

---

## 9. Шаблоны для частых случаев

### 9.1. Тест успешной операции

```markdown
### Тест X.Y: Успешное [название операции]

**Цель**: проверить корректность выполнения [операции]

**Предусловия**:
- Ресурс А существует со значением [конкретное значение]
- Ресурс Б существует со значением [конкретное значение]

**Шаги**:
1. [Выполнить операцию с конкретными параметрами]
2. Проверить результат выполнения
3. Проверить состояние ресурса А
4. Проверить состояние ресурса Б

**Ожидаемый результат**:
- Операция выполнена успешно (HTTP 200 или UI-уведомление)
- Состояние ресурса А: [конкретное новое значение]
- Состояние ресурса Б: [конкретное новое значение]
- Операция зафиксирована в журнале/истории
```

### 9.2. Тест ошибки бизнес-логики

```markdown
### Тест X.Y: [Название ошибочной ситуации]

**Цель**: проверить обработку ситуации [описание]

**Предусловия**:
- Ресурс А существует в состоянии [состояние, вызывающее ошибку]

**Шаги**:
1. Попытаться выполнить операцию [которая должна завершиться ошибкой]

**Ожидаемый результат**:
- Операция отклонена с ошибкой (HTTP 4XX или UI-уведомление об ошибке)
- Код ошибки: [конкретный код]
- Сообщение: "[конкретное сообщение]"
- Состояние ресурса А не изменилось: [исходное значение]
- Никакие данные не изменились
```

### 9.3. Тест идемпотентности

```markdown
### Тест X.Y: Идемпотентность [операции]

**Цель**: проверить, что повторное выполнение операции не дублирует эффект

**Предусловия**:
- Ресурс А существует со значением [значение]

**Шаги**:
1. Выполнить операцию с ключом идемпотентности KEY-001
2. Сохранить результат операции (ID, новое состояние)
3. Повторно выполнить ту же операцию с тем же ключом KEY-001

**Ожидаемый результат**:
- Первый запрос выполнен успешно, возвращен ID операции: [ID]
- Второй запрос возвращает тот же ID: [ID]
- Состояние ресурса А изменилось только один раз: [конкретное значение]
- В журнале только одна запись об операции
```

### 9.4. Тест на консистентность

```markdown
### Тест X.Y: Консистентность между [компонент А] и [компонент Б]

**Цель**: проверить согласованность данных в распределенной системе

**Предусловия**:
- Известно начальное состояние системы

**Шаги**:
1. Выполнить [количество] операций
2. Получить данные из компонента А
3. Получить данные из компонента Б
4. Сравнить и вычислить инвариант

**Ожидаемый результат**:
- Данные в компоненте А: [конкретное значение]
- Данные в компоненте Б: [конкретное значение]
- Инвариант сохранен: [формула] = [ожидаемое значение]
- Нет расхождений между компонентами
```

---

## 10. Checklist перед финализацией плана

Перед тем как считать план готовым, проверьте:

### Общее

- [ ] План содержит все основные сценарии, которые реально успеть продемонстрировать на демо (не более 10-15 сценариев) 
- [ ] Тестируется только реализованная функциональность MVP
- [ ] Указан способ тестирования (API/UI/комбинированный)

### Каждый тест

- [ ] Имеет четкое название (3-7 слов)
- [ ] Содержит раздел "Цель" (одно предложение)
- [ ] Содержит конкретные "Предусловия" с числовыми значениями
- [ ] Шаги описаны однозначно и последовательно
- [ ] "Ожидаемый результат" содержит конкретные значения
- [ ] Нет вариантов результата ("или", "может быть")
- [ ] Проверяются побочные эффекты, а не только ответ API/UI

### Покрытие

- [ ] Есть минимум 1 успешный позитивный сценарий
- [ ] Есть минимум 2 ошибки бизнес-логики
- [ ] Есть минимум 1 комплексный сценарий
- [ ] Есть минимум 1 тест на консистентность данных

### Качество

- [ ] Все тесты проверяют бизнес-логику, а не валидацию входных данных
- [ ] Нет упоминаний конкретных инструментов тестирования
- [ ] Нет тестов нереализованной функциональности
- [ ] Все значения в тестах конкретные (не "несколько", а "3")

---

## Заключение

Хороший план E2E тестирования для демонстрации:
- **Фокусируется на MVP** — тестирует только то, что реализовано
- **Проверяет бизнес-логику** — а не валидацию формата данных
- **Содержит конкретику** — точные значения, однозначные результаты
- **Оптимален по объему** — не более 10-15 тестов для 20-минутного демо
- **Логично структурирован** — от простого к сложному, от позитива к негативу
- **Покрывает ключевые аспекты** — функциональность, ошибки, консистентность

Следуя этим рекомендациям, вы создадите план, который эффективно демонстрирует работоспособность вашей распределенной системы за ограниченное время.